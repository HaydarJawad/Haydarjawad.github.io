<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://haydarjawad.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://haydarjawad.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-29T13:36:28+00:00</updated><id>https://haydarjawad.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">a post with pseudo code</title><link href="https://haydarjawad.github.io/blog/2024/pseudocode/" rel="alternate" type="text/html" title="a post with pseudo code"/><published>2024-04-15T00:01:00+00:00</published><updated>2024-04-15T00:01:00+00:00</updated><id>https://haydarjawad.github.io/blog/2024/pseudocode</id><content type="html" xml:base="https://haydarjawad.github.io/blog/2024/pseudocode/"><![CDATA[<pre><code class="language-pseudocode">% This algorithm checks the axioms of probability for an AI image classification model
\begin{algorithm}
\caption{Check Probabilities of Image Classification Model}
\begin{algorithmic}
\PROCEDURE{CheckProbabilities}{$$sample\_space, event\_A, event\_B$$}
    \STATE $total\_images \gets$ \CALL{Length}{$$sample\_space$$}
    \STATE $prob\_A \gets$ \CALL{Length}{$event\_A$} / $total\_images$
    \STATE $prob\_B \gets$ \CALL{Length}{$event\_B$} / $total\_images$

    \PROCEDURE{NonNegativity}{$prob$}
        \IF{$prob \geq 0$}
            \STATE \textbf{return} True
        \ELSE
            \STATE \textbf{return} False
        \ENDIF
    \ENDPROCEDURE

    \PROCEDURE{Normalisation}{$prob\_A, prob\_B$}
        \IF{$prob\_A + prob\_B = 1$}
            \STATE \textbf{return} True
        \ELSE
            \STATE \textbf{return} False
        \ENDIF
    \ENDPROCEDURE

    \PROCEDURE{Additivity}{$prob\_A, prob\_B$}
        \IF{$prob\_A + prob\_B \leq 1$}
            \STATE \textbf{return} True
        \ELSE
            \STATE \textbf{return} False
        \ENDIF
    \ENDPROCEDURE

    \STATE $is\_non\_negative \gets$ \CALL{NonNegativity}{$prob\_A$} \AND \CALL{NonNegativity}{$prob\_B$}
    \STATE $is\_normalised \gets$ \CALL{Normalisation}{$prob\_A, prob\_B$}
    \STATE $is\_additive \gets$ \CALL{Additivity}{$prob\_A, prob\_B$}

    \IF{$is\_non\_negative$}
        \STATE \textbf{print}("Non-negativity check passed")
    \ELSE
        \STATE \textbf{print}("Non-negativity check failed")
    \ENDIF

    \IF{$is\_normalised$}
        \STATE \textbf{print}("Normalisation check passed")
    \ELSE
        \STATE \textbf{print}("Normalisation check failed")
    \ENDIF

    \IF{$is\_additive$}
        \STATE \textbf{print}("Additivity check passed")
    \ELSE
        \STATE \textbf{print}("Additivity check failed")
    \ENDIF

    \STATE \textbf{print}("Probability of image being a cat: ", $prob\_A$)
    \STATE \textbf{print}("Probability of image being a dog: ", $prob\_B$)

\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}

</code></pre>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="code"/><summary type="html"><![CDATA[this is what included pseudo code could look like]]></summary></entry><entry><title type="html">Set Theory Basics and its links to AI</title><link href="https://haydarjawad.github.io/blog/2022/distill5/" rel="alternate" type="text/html" title="Set Theory Basics and its links to AI"/><published>2022-05-28T00:00:00+00:00</published><updated>2022-05-28T00:00:00+00:00</updated><id>https://haydarjawad.github.io/blog/2022/distill5</id><content type="html" xml:base="https://haydarjawad.github.io/blog/2022/distill5/"><![CDATA[<h1 style="text-align: center; color: blue !important;">Set Theory Basics and its links to AI</h1> <h5 id="haydar-jawad-may-2022">Haydar jawad, May 2022</h5> <h1 id="set-theory-basics">Set Theory Basics</h1> <h2 id="what-is-set-theory">What is Set Theory?</h2> <p>Set theory is like organising things into groups (called sets). Imagine you have a bunch of different toys. You can group them into sets like “cars,” “dolls,” and “blocks.”</p> <h3 id="definitions">Definitions:</h3> <ul> <li>Set (S): A collection of objects (called elements). For example, if you have toys, your set could be: \(S = \{ \text{car, doll, block} \}\)</li> <li>Element: An object in a set. In the set above, “car” is an element.</li> <li>Sample Space (S): The set of all possible outcomes of an experiment. If you toss a coin, the sample space is: \(S = \{ \text{Heads (H), Tails (T)} \}\)</li> </ul> <h3 id="types-of-sets">Types of Sets:</h3> <ul> <li>Finite Set: A set with a limited number of elements. For example, a set of primary colours: \(\{ \text{Red, Blue, Yellow} \}\)</li> <li>Infinite Set: A set with unlimited elements. For example, the set of all positive numbers: \(\{ 1, 2, 3, \ldots \}\)</li> </ul> <h3 id="important-operations-on-sets">Important Operations on Sets:</h3> <ul> <li>Union ( \(A \cup B\) ): Combines all elements from both sets A and B.</li> <li>Intersection ( \(A \cap B\) ): Includes only elements found in both sets A and B.</li> <li>Complement ( \(A^C\) ): Includes everything not in set A.</li> </ul> <h3 id="examples">Examples:</h3> <ul> <li>Union Example: If \(A = \{ \text{apple, banana} \}\) and \(B = \{ \text{banana, cherry} \}\), then \(A \cup B = \{ \text{apple, banana, cherry} \}\)</li> <li>Intersection Example: If \(A = \{ \text{apple, banana} \}\) and \(B = \{ \text{banana, cherry} \}\), then \(A \cap B = \{ \text{banana} \}\)</li> <li>Complement Example: If the universal set \(U = \{ \text{apple, banana, cherry, date} \}\) and \(A = \{ \text{apple, banana} \}\), then \(A^C = \{ \text{cherry, date} \}\)</li> </ul> <h3 id="basic-properties">Basic Properties:</h3> <ul> <li>Commutativity: <ul> <li>Union: \(A \cup B = B \cup A\)</li> <li>Intersection: \(A \cap B = B \cap A\)</li> </ul> </li> <li>Associativity: <ul> <li>Union: \(A \cup (B \cup C) = (A \cup B) \cup C\)</li> <li>Intersection: \(A \cap (B \cap C) = (A \cap B) \cap C\)</li> </ul> </li> <li>Distributive Laws: <ul> <li> \[A \cap (B \cup C) = (A \cap B) \cup (A \cap C)\] </li> <li> \[A \cup (B \cap C) = (A \cup B) \cap (A \cup C)\] </li> </ul> </li> <li>De Morgan’s Laws: <ul> <li> \[(A \cup B)^C = A^C \cap B^C\] </li> <li> \[(A \cap B)^C = A^C \cup B^C\] </li> </ul> </li> </ul> <h2 id="set-theory-properties-with-examples">Set Theory Properties with Examples</h2> <ol> <li><strong>Commutativity</strong> <ul> <li>Union ( \(A \cup B\) ): The order in which you combine sets doesn’t matter. <ul> <li>Example: If \(A = \{ \text{apple, banana} \}\) and \(B = \{ \text{banana, cherry} \}\), then \(A \cup B = B \cup A = \{ \text{apple, banana, cherry} \}\)</li> </ul> </li> <li>Intersection ( \(A \cap B\) ): The order in which you find common elements doesn’t matter. <ul> <li>Example: Using the same sets, \(A \cap B = B \cap A = \{ \text{banana} \}\)</li> </ul> </li> </ul> </li> <li><strong>Associativity</strong> <ul> <li>Union ( \(A \cup (B \cup C)\) ): It doesn’t matter how you group the sets when you combine them. <ul> <li>Example: If \(A = \{ \text{apple} \}\), \(B = \{ \text{banana} \}\), and \(C = \{ \text{cherry} \}\), then \(A \cup (B \cup C) = (A \cup B) \cup C = \{ \text{apple, banana, cherry} \}\)</li> </ul> </li> <li>Intersection ( \(A \cap (B \cap C)\) ): It doesn’t matter how you group the sets when you find common elements. <ul> <li>Example: If \(A = \{ 1, 2, 3 \}\), \(B = \{ 2, 3, 4 \}\), and \(C = \{ 3, 4, 5 \}\), then \(A \cap (B \cap C) = (A \cap B) \cap C = \{ 3 \}\)</li> </ul> </li> </ul> </li> <li><strong>Distributive Laws</strong> <ul> <li>Intersection over Union ( \(A \cap (B \cup C)\) ): Finding common elements with the union of other sets is the same as combining the intersections separately. <ul> <li>Example: If \(A = \{ \text{apple, banana} \}\), \(B = \{ \text{banana, cherry} \}\), and \(C = \{ \text{cherry, date} \}\), then \(A \cap (B \cup C) = (A \cap B) \cup (A \cap C) = \{ \text{banana} \}\)</li> </ul> </li> <li>Union over Intersection ( \(A \cup (B \cap C)\) ): Combining a set with the common elements of other sets is the same as finding the union of the intersections separately. <ul> <li>Example: If \(A = \{ \text{apple, banana} \}\), \(B = \{ \text{banana, cherry} \}\), and \(C = \{ \text{banana, date} \}\), then \(A \cup (B \cap C) = (A \cup B) \cap (A \cup C) = \{ \text{apple, banana, cherry} \}\)</li> </ul> </li> </ul> </li> <li><strong>De Morgan’s Laws</strong> <ul> <li>Complement of Union ( \((A \cup B)^C\) ): The complement of the union is the same as the intersection of the complements. <ul> <li>Example: If \(A = \{ \text{apple} \}\), \(B = \{ \text{banana} \}\), and the universal set \(U = \{ \text{apple, banana, cherry, date} \}\), then \((A \cup B)^C = A^C \cap B^C = \{ \text{cherry, date} \}\)</li> </ul> </li> <li>Complement of Intersection ( \((A \cap B)^C\) ): The complement of the intersection is the same as the union of the complements. <ul> <li>Example: Using the same sets, \((A \cap B)^C = A^C \cup B^C = \{ \text{apple, banana, cherry, date} \}^C = \{ \text{cherry, date} \}\)</li> </ul> </li> </ul> </li> </ol> <h3 id="recap-with-visualisation">Recap with Visualisation</h3> <ul> <li>Union ( \(A \cup B\) ): Combining everything in both sets.</li> <li>Intersection ( \(A \cap B\) ): Finding what is common in both sets.</li> <li>Complement ( \(A^C\) ): Everything not in the set.</li> <li>Commutativity: Order doesn’t matter.</li> <li>Associativity: Grouping doesn’t matter.</li> <li>Distributive Laws: Combining and finding common elements can be distributed.</li> <li>De Morgan’s Laws: Complement of combined sets can be separated into individual complements.</li> </ul> <p>These rules help us organise and understand groups of things better, making it easier to solve problems involving sets!</p> <p>By understanding these basic concepts, you can solve problems involving groups of objects and how they interact with each other. It’s like using a superpower to organise and understand the world better!</p> <h3 id="example-of-set-theory-in-ai-image-classification">Example of Set Theory in AI: Image Classification</h3> <p>Imagine you’re training a computer to recognise whether an image contains a cat or a dog. You have a collection of images, and you want the computer to learn from these images.</p> <h4 id="sample-space-and-events">Sample Space and Events</h4> <ol> <li><strong>Sample Space (S)</strong>: <ul> <li>This is the set of all possible images the computer might see.</li> <li>Example: \(S = \{\text{Image1}, \text{Image2}, \text{Image3}, \ldots, \text{ImageN}\}\)</li> </ul> </li> <li><strong>Events</strong>: <ul> <li><strong>Event A</strong>: Set of images containing cats.</li> <li><strong>Event B</strong>: Set of images containing dogs.</li> <li>Example: \(A = \{\text{Image2}, \text{Image4}, \text{Image6}\}\)</li> <li>Example: \(B = \{\text{Image1}, \text{Image3}, \text{Image5}\}\)</li> </ul> </li> </ol> <h4 id="using-set-operations-in-ai">Using Set Operations in AI</h4> <ol> <li><strong>Union ( \(A \cup B\) )</strong>: <ul> <li>Represents all images that contain either cats or dogs or both.</li> <li>Equation: \(A \cup B\)</li> <li>Example: If \(A = \{\text{Image2}, \text{Image4}, \text{Image6}\}\) and \(B = \{\text{Image1}, \text{Image3}, \text{Image5}\}\), then: \(A \cup B = \{\text{Image1}, \text{Image2}, \text{Image3}, \text{Image4}, \text{Image5}, \text{Image6}\}\)</li> </ul> </li> <li><strong>Intersection ( \(A \cap B\) )</strong>: <ul> <li>Represents all images that contain both cats and dogs (though this might be rare in simple classification tasks).</li> <li>Equation: \(A \cap B\)</li> <li>Example: If there’s no overlap (no image contains both a cat and a dog): \(A \cap B = \emptyset\) (empty set, no common images)</li> </ul> </li> <li><strong>Complement ( \(A^C\) )</strong>: <ul> <li>Represents all images that do not contain cats.</li> <li>Equation: \(A^C = S - A\)</li> <li>Example: If \(S = \{\text{Image1}, \text{Image2}, \text{Image3}, \text{Image4}, \text{Image5}, \text{Image6}\}\) and \(A = \{\text{Image2}, \text{Image4}, \text{Image6}\}\), then: \(A^C = \{\text{Image1}, \text{Image3}, \text{Image5}\}\)</li> </ul> </li> <li><strong>Difference ( \(A - B\) )</strong>: <ul> <li>Represents all images that contain cats but not dogs.</li> <li>Equation: \(A - B\)</li> <li>Example: If \(A = \{\text{Image2}, \text{Image4}, \text{Image6}\}\) and \(B = \{\text{Image1}, \text{Image3}, \text{Image5}\}\), then: \(A - B = A\) (since there’s no overlap)</li> </ul> </li> </ol> <h4 id="practical-use-in-ai">Practical Use in AI</h4> <p>In AI, especially in machine learning, we often deal with sets of data (like images) and use set theory to:</p> <ul> <li><strong>Classify data</strong>: Determine which category an image belongs to (e.g., cat or dog).</li> <li><strong>Train models</strong>: Use subsets of data (training set) to teach the model and another subset (test set) to check its accuracy.</li> <li><strong>Evaluate models</strong>: Measure how well the model is performing by calculating intersections (correct classifications) and complements (errors).</li> </ul> <h3 id="summary">Summary</h3> <p>Set theory helps us organise and manipulate groups of data in AI, whether we’re classifying images, training models, or evaluating performance. Understanding how sets work makes it easier to handle the large amounts of data AI models need to learn from.</p>]]></content><author><name></name></author><category term="ML mathematics"/><summary type="html"><![CDATA[Set Theory Basics and its links to AI]]></summary></entry><entry><title type="html">The 4 elements that influence security</title><link href="https://haydarjawad.github.io/blog/2022/sec1/" rel="alternate" type="text/html" title="The 4 elements that influence security"/><published>2022-05-28T00:00:00+00:00</published><updated>2022-05-28T00:00:00+00:00</updated><id>https://haydarjawad.github.io/blog/2022/sec1</id><content type="html" xml:base="https://haydarjawad.github.io/blog/2022/sec1/"><![CDATA[<h1 style="text-align: center; color: blue !important;">Foundations of Probability and its links to AI</h1> <h5 id="haydar-jawad-may-2022">Haydar jawad, May 2022</h5> <p>| Example | Key Points | Policy | Mechanism | Assurance | Incentives | | :————- | :—————————————————————————————————————————————————————————————————————————————- | :——————————————————————- | :—————————————————————————————- | :———————————————————————— | :————————————————————————– | | <strong>Bank</strong> | - <strong>Core Bookkeeping System</strong>: Protects records of customer accounts using methods like requiring two people to authorise big transfers and regular checks for unusual activity. | Protect customer accounts and transactions. | Dual authorisation, regular audits. | Regular checks and balances. | Job security, integrity policies. | | | - <strong>ATMs</strong>: Uses cards and PINs for access, with encryption to prevent unauthorised withdrawals. | Protect cash withdrawals. | PINs, encryption, secure hardware. | Monitoring of withdrawal patterns. | Trust in banking services, avoiding fraud. | | | - <strong>Online Banking</strong>: Adds extra security steps like sending a code to the customer’s phone to protect against phishing. | Secure online transactions. | Multi-factor authentication (MFA), encryption. | Regular updates and security audits. | Customer satisfaction, prevention of fraud. | | | - <strong>High-Value Messaging Systems</strong>: Employs strict controls and encryption to protect large money transfers. | Secure high-value transfers. | Access controls, encryption, logging. | Audits and transaction monitoring. | Maintain financial integrity, avoid large-scale theft. | | | - <strong>Bank Branches</strong>: Relies on alarms and security companies for physical security. | Protect physical assets and cash. | Alarms, security personnel, secure vaults. | Regular maintenance and testing of security systems. | Protection of physical assets, safety of staff and customers. | | <strong>Military Base</strong> | - <strong>Military Communications</strong>: Utilises advanced cryptography to keep messages private and techniques to avoid detection. | Secure military communications. | Cryptography, low-probability-of-intercept (LPI) techniques. | Regular testing and evaluation. | National security, mission success. | | | - <strong>Electronic Warfare</strong>: Uses technology to trick or block enemy radar and communication systems. | Protect own radar and communications, disrupt enemy’s. | Jamming techniques, deception strategies. | Continuous monitoring and adaptation. | Strategic advantage, mission success. | | | - <strong>Top Secret Information</strong>: Handles sensitive information on highly secure systems to limit access. | Protect sensitive military information. | Secure systems, compartmentalisation, access controls. | Regular security audits, strict protocols. | Protect national security, prevent leaks. | | | - <strong>Nuclear Weapons</strong>: Employs advanced security technology to ensure only authorised use. | Prevent unauthorised use of nuclear weapons. | Secure authentication systems, biometric identification. | Continuous testing and strict protocols. | Avoid catastrophic consequences, ensure authorised use only. | | <strong>Hospital</strong> | - <strong>Safety Usability of Medical Equipment</strong>: Ensures devices are safe and easy to use to prevent fatal errors. | Ensure patient safety and effective use of equipment. | Standardised equipment interfaces, safety protocols. | Regular training, maintenance checks. | Patient safety, compliance with health regulations. | | | - <strong>Patient Records</strong>: Limits access to sensitive information to protect privacy. | Protect patient privacy and confidentiality. | Access controls, encryption, audit logs. | Regular audits, compliance checks. | Trust in healthcare system, legal compliance. | | | - <strong>Anonymising Patient Data</strong>: Removes personal details from records used for research. | Ensure privacy in research data. | De-identification techniques, secure data storage. | Validation of anonymisation processes. | Enable research while protecting privacy, compliance with laws. | | | - <strong>New Technology Risks</strong>: Manages risks from digital and networked devices to maintain operations during cyber attacks. | Protect hospital operations from cyber threats. | Network security measures, backup systems. | Regular security assessments, incident response plans. | Ensure continuous patient care, protect critical systems. | | <strong>Home</strong> | - <strong>Online Banking and Doctor’s Appointments</strong>: Uses the internet securely for managing bank accounts and scheduling appointments. | Protect personal financial and health information. | Encryption, secure access methods. | Regular security updates, user education. | Convenience, trust in online services. | | | - <strong>Car Security</strong>: Modern cars use electronic systems to prevent theft, which include encrypted signals between the car and key. | Prevent car theft. | Encrypted key fobs, immobilisers. | Regular testing and updates. | Protect personal property, insurance benefits. | | | - <strong>Mobile Phones</strong>: Utilises encryption to secure communications and protect data, although can be compromised by fake cell towers. | Secure personal communications and data. | Encryption, secure SIM cards. | Regular security updates, monitoring. | Protect personal information, avoid fraud. | | | - <strong>Prepayment Meters</strong>: Secures systems where households prepay for utilities using codes. | Ensure secure and reliable prepayment for utilities. | Secure code generation and verification. | Regular audits and validation. | Reliable utility access, trust in the system. | | | - <strong>Home Security and Smart Devices</strong>: Includes burglar alarms and smart devices like Amazon Alexa or Google Home, which use encrypted signals and raise privacy concerns due to constant listening. | Protect home privacy and security. | Encrypted communications, secure device setup. | Regular updates, security patches. | Personal safety, privacy, convenience. |</p>]]></content><author><name></name></author><category term="statistics and probability"/><summary type="html"><![CDATA[Foundations of Probability and its links to AI]]></summary></entry><entry><title type="html">Foundations of Probability and its links to AI</title><link href="https://haydarjawad.github.io/blog/2022/statsaxi/" rel="alternate" type="text/html" title="Foundations of Probability and its links to AI"/><published>2022-05-28T00:00:00+00:00</published><updated>2022-05-28T00:00:00+00:00</updated><id>https://haydarjawad.github.io/blog/2022/statsaxi</id><content type="html" xml:base="https://haydarjawad.github.io/blog/2022/statsaxi/"><![CDATA[<h1 style="text-align: center; color: blue !important;">Foundations of Probability and its links to AI</h1> <h5 id="haydar-jawad-may-2022">Haydar jawad, May 2022</h5> <h2 id="what-are-axioms">What are Axioms?</h2> <p>Axioms are basic rules or principles that we accept as true without needing proof. They are like the building blocks or foundations of a theory.</p> <h2 id="what-is-probability">What is Probability?</h2> <p>Probability is a way of measuring how likely something is to happen. It’s like saying how sure you are that an event will occur.</p> <h2 id="the-three-axioms-of-probability">The Three Axioms of Probability</h2> <ol> <li> <p><strong>Non-negativity (Axiom 1)</strong></p> <p>This means that the probability of any event is always a non-negative number (zero or positive). You can’t have a negative chance of something happening.</p> <p><strong>Example:</strong> If you have a set of images and you’re classifying them as either cat images or not, the probability of an image being a cat (\(P(\text{cat})\)) is always a number from 0 to 1.</p> </li> <li> <p><strong>Normalisation (Axiom 2)</strong></p> <p>The total probability of all possible outcomes in the sample space is 1. This means that something must happen; the sum of probabilities of all events equals 1.</p> <p><strong>Example:</strong> If you have a machine learning model that predicts whether an image is a cat or not, the probabilities of being a cat (\(P(\text{cat})\)) and not being a cat (\(P(\text{not cat})\)) must add up to 1.</p> </li> <li> <p><strong>Additivity (Axiom 3)</strong></p> <p>If two events cannot happen at the same time (they are mutually exclusive), the probability that one or the other happens is the sum of their individual probabilities.</p> <p><strong>Example:</strong> If you have an image classification model that predicts either a cat or a dog (and an image cannot be both at the same time), the probability of the image being a cat or a dog is the sum of the probability of it being a cat and the probability of it being a dog.</p> </li> </ol> <h2 id="applying-the-axioms-in-ai">Applying the Axioms in AI</h2> <p>Let’s see how these axioms apply in AI, particularly in a scenario where we use a machine learning model to classify images as either containing cats or dogs.</p> <p><strong>Example: Image Classification in AI</strong></p> <ul> <li> <p><strong>Non-negativity (Axiom 1):</strong> Your AI model assigns probabilities to images. For any image, the probability \(P(\text{cat})\) must be between 0 and 1.</p> <p><strong>Example:</strong> An image has a 0.8 probability of being a cat. This means the model is 80% sure the image is a cat. You can’t have a -0.5 or 1.5 probability.</p> </li> <li> <p><strong>Normalisation (Axiom 2):</strong> The model assigns probabilities to all possible categories (cat or dog). The total probability must add up to 1.</p> <p><strong>Example:</strong> If the model gives \(P(\text{cat}) = 0.7\), then \(P(\text{dog}) = 0.3\) because \(0.7 + 0.3 = 1\).</p> </li> <li> <p><strong>Additivity (Axiom 3):</strong> For mutually exclusive events (an image can’t be both a cat and a dog at the same time), the probability of either event happening is the sum of their probabilities.</p> <p><strong>Example:</strong> If the model predicts that an image has a 0.6 probability of being a cat and a 0.4 probability of being a dog, the combined probability of the image being either a cat or a dog is: \(P(\text{cat or dog}) = P(\text{cat}) + P(\text{dog}) = 0.6 + 0.4 = 1\).</p> </li> </ul> <h2 id="recap-with-formulas">Recap with Formulas</h2> <ul> <li><strong>Non-negativity:</strong> \(P(A) \geq 0\) for any event \(A\).</li> <li><strong>Normalisation:</strong> \(P(S) = 1\) where \(S\) is the sample space.</li> <li><strong>Additivity:</strong> If \(A\) and \(B\) are mutually exclusive, \(P(A \cup B) = P(A) + P(B)\).</li> </ul> <h2 id="visualising-with-an-example">Visualising with an Example</h2> <p>Imagine you have 10 images, and your AI model classifies each image. Here’s how the axioms work:</p> <ul> <li><strong>Non-negativity:</strong> The probability of any image being a cat or dog is always between 0 and 1.</li> <li><strong>Normalisation:</strong> For each image, the probabilities of all possible outcomes (cat or dog) add up to 1.</li> <li><strong>Additivity:</strong> If an image can’t be both a cat and a dog, the probability of it being either a cat or a dog is the sum of the two individual probabilities.</li> </ul> <p>By understanding and applying these axioms, AI systems can make reliable and consistent predictions based on probabilities.</p>]]></content><author><name></name></author><category term="statistics and probability"/><summary type="html"><![CDATA[Foundations of Probability and its links to AI]]></summary></entry><entry><title type="html">why would we care about P=NP anyway</title><link href="https://haydarjawad.github.io/blog/2022/distill4/" rel="alternate" type="text/html" title="why would we care about P=NP anyway"/><published>2022-05-26T00:00:00+00:00</published><updated>2022-05-26T00:00:00+00:00</updated><id>https://haydarjawad.github.io/blog/2022/distill4</id><content type="html" xml:base="https://haydarjawad.github.io/blog/2022/distill4/"><![CDATA[<h1 style="text-align: center; color: blue !important;">So why would we care about P=NP anyway</h1> <h5 id="haydar-jawad-may-2022">Haydar jawad, May 2022</h5> <p><strong>Introduction</strong></p> <p>Imagine you have a favourite game that you are very good at, but there’s a part of it you can’t figure out if it’s even possible to master. In the world of computer science, there’s a huge question that’s like this, called the P=NP problem. Scientists are trying to figure out if every problem that’s easy to check (NP) is also easy to solve (P). But why do many scientists believe that P is not equal to NP (P≠NP)?</p> <h3 id="why-scientists-bet-pnp">Why Scientists Bet P≠NP</h3> <p>Here are some reasons why scientists think P≠NP, explained in simple terms with some maths:</p> <ol> <li><strong>Too Good to Be True</strong></li> </ol> <p>If P were equal to NP, it would mean that all kinds of very hard problems suddenly have easy solutions. This seems too good to be true. For example, solving puzzles, cracking codes, and even creating new inventions would become easy.</p> <ol> <li><strong>Thousands of Problems Would Become Easy</strong></li> </ol> <p>There are thousands of different problems in the NP group. If one problem in NP is easy to solve, then all of them would be. It’s hard to believe there’s a single method to solve all these different problems.</p> <h3 id="mathematical-examples">Mathematical Examples</h3> <h4 id="example-of-a-problem-in-p-sorting-numbers">Example of a Problem in P: Sorting Numbers</h4> <p>Let’s take a list of numbers and sort them. Sorting algorithms like quicksort or mergesort can do this in \(O(n \log n)\) time. Here’s how it works:</p> <ul> <li><strong>Problem:</strong> Sort the list [5, 3, 8, 6, 2].</li> <li><strong>Solution:</strong> Use an algorithm like mergesort.</li> <li><strong>Time Complexity:</strong> \(O(n \log n)\).</li> </ul> \[T(n) = n \log n\] <p>For example, if \(n = 8\):</p> \[T(8) = 8 \log 8 = 8 \times 3 = 24 \text{ steps}\] <p>Sorting is a P problem because it can be done quickly.</p> <h4 id="example-of-a-problem-in-np-sudoku">Example of a Problem in NP: Sudoku</h4> <p>Sudoku is a great example of an NP problem:</p> <ul> <li><strong>Problem:</strong> Fill a 9x9 grid with numbers 1 to 9 so that each row, column, and 3x3 box contains all numbers from 1 to 9.</li> <li><strong>Solution:</strong> Finding the solution can be very hard, but checking if a given solution is correct is easy.</li> <li><strong>Verification:</strong> Check if each row, column, and box has numbers 1 to 9.</li> </ul> <p>If someone gives you a filled Sudoku grid, you can check it quickly to see if it’s correct.</p> <h3 id="what-if-pnp">What If P=NP?</h3> <p>If P were equal to NP, it would mean that every problem that is easy to check is also easy to solve. This has huge implications, especially for cryptography. Here’s why:</p> <ol> <li><strong>Cryptography Basics</strong></li> </ol> <p>Cryptography is about creating codes that are hard to break. For example, when you send a message over the internet, it’s encrypted so that only the intended recipient can read it. This encryption relies on certain mathematical problems being hard to solve.</p> <ol> <li><strong>Example: RSA Encryption</strong></li> </ol> <p>RSA encryption is a common method used to secure online communications. It relies on the difficulty of factoring large numbers into their prime factors. For instance, if you multiply two large prime numbers together, it’s easy. But if you only have the product and not the original primes, figuring out the prime factors is very hard.</p> <ul> <li><strong>Problem:</strong> Given a large number \(N\), find its prime factors.</li> <li><strong>Difficulty:</strong> This is believed to be a hard problem, taking a long time to solve.</li> </ul> <ol> <li><strong>Impact of P=NP on Cryptography</strong></li> </ol> <p>If P=NP, it would mean there’s a quick way to solve this hard problem. In other words, if someone could find a fast algorithm to factorise large numbers, they could break RSA encryption easily.</p> <ul> <li><strong>Consequences:</strong> <ul> <li><strong>Broken Security:</strong> All the encrypted messages that rely on RSA (like your online banking, emails, etc.) would no longer be secure.</li> <li><strong>New Algorithms Needed:</strong> Cryptographers would need to find new methods to secure communications that don’t rely on problems in NP.</li> </ul> </li> </ul> <h3 id="could-agi-find-the-solution">Could AGI Find the Solution?</h3> <p><strong>AGI (Artificial General Intelligence)</strong> refers to a type of AI that has the ability to understand, learn, and apply knowledge in a way similar to a human being. The idea is that AGI would be capable of performing any intellectual task that a human can do.</p> <ol> <li><strong>Problem-Solving Capabilities</strong></li> </ol> <p>AGI could potentially find solutions to very complex problems because it would have the ability to think creatively, learn from experience, and use a vast amount of knowledge and computational power. This means AGI might be able to find an algorithm that solves NP problems efficiently, thereby proving that P=NP.</p> <ol> <li><strong>Implications for Cryptography</strong></li> </ol> <p>If AGI were to find a solution that proves P=NP, it would revolutionise many fields, including cryptography. All current cryptographic systems based on NP problems would become insecure. However, AGI could also help develop new cryptographic methods that do not rely on the hardness of NP problems.</p> <ol> <li><strong>Current AI vs AGI</strong></li> </ol> <p>Current AI, known as Narrow AI, is very good at specific tasks like playing chess or recognising images, but it cannot solve general problems like proving P=NP. AGI, on the other hand, would have the general problem-solving ability required to tackle such fundamental questions in computer science.</p> <h3 id="conclusion">Conclusion</h3> <p>Understanding the P=NP problem helps us see why it’s such a big deal in computer science and cryptography. If P=NP, it would make solving hard problems easy, which sounds great, but it would also mean that current cryptographic methods would be useless, leading to a need for new ways to secure our data. AGI, with its advanced problem-solving abilities, could potentially find a solution to P=NP, but this would come with significant implications for security and technology. Scientists believe P≠NP because it seems too good to be true that all these hard problems could have easy solution.</p>]]></content><author><name></name></author><category term="computer science"/><summary type="html"><![CDATA[So why would we care about P=NP anyway]]></summary></entry><entry><title type="html">Understanding P and NP</title><link href="https://haydarjawad.github.io/blog/2022/distill2/" rel="alternate" type="text/html" title="Understanding P and NP"/><published>2022-05-25T00:00:00+00:00</published><updated>2022-05-25T00:00:00+00:00</updated><id>https://haydarjawad.github.io/blog/2022/distill2</id><content type="html" xml:base="https://haydarjawad.github.io/blog/2022/distill2/"><![CDATA[<h1 style="text-align: center; color: blue !important;">Understanding P and NP </h1> <h5 id="haydar-jawad-may-2022">Haydar jawad, May 2022</h5> <p><strong>Understanding \(P\) and \(NP\)</strong></p> <p>Imagine you have a bunch of puzzles. Some puzzles are easy to solve, while others are easy to check if someone else has solved them correctly. In computer science, the puzzles that are easy to solve are in a group called \(P\) (Polynomial time). The puzzles that are easy to check are in a group called \(NP\) (Nondeterministic Polynomial time). The big question is whether every puzzle that is easy to check (\(NP\)) is also easy to solve (\(P\)). This question is known as “Is \(P=NP\)?”.</p> <p><strong>Riemann Hypothesis vs. \(P=NP\)</strong></p> <p>The Riemann Hypothesis (RH) is another famous problem in mathematics. It deals with prime numbers and how they are spread out. If someone finds one exception to RH, it would mean RH is false. But \(P=NP\) is more complex. If \(P\) were equal to \(NP\), it could mean different things about how difficult or easy it is to solve certain problems.</p> <h3 id="the-riemann-hypothesis-explained">The Riemann Hypothesis Explained</h3> <p>The Riemann Hypothesis is about prime numbers and a special function called the Riemann zeta function, written as \(\zeta(s)\). This function is defined for complex numbers and is given by:</p> <p>[ \zeta(s) = \sum_{n=1}^{\infty} \frac{1}{n^s} ]</p> <p>Let’s break this down:</p> <ul> <li>\(\zeta(s)\): This is the Riemann zeta function.</li> <li>\(\sum_{n=1}^{\infty}\): This means you are adding up an infinite series of numbers.</li> <li>\(\frac{1}{n^s}\): This means you take each number \(n\), raise it to the power of \(s\), and then take the reciprocal (1 divided by that number).</li> </ul> <p>The Riemann Hypothesis says that all the interesting solutions to the equation \(\zeta(s) = 0\) lie on a specific line in the complex number plane. This line is called the “critical line,” and it is where the real part of \(s\) is \(\frac{1}{2}\). So, if \(s = \frac{1}{2} + bi\) (where \(b\) is a real number), the Riemann Hypothesis predicts that all the non-trivial zeros of the zeta function lie on this line.</p> <h3 id="comparison-with-pnp">Comparison with \(P=NP\)</h3> <p>The Riemann Hypothesis is a “yes or no” question: either all the non-trivial zeros lie on the critical line, or they don’t. If one zero is found off the line, the hypothesis is false. This is different from the \(P=NP\) problem, which has multiple potential outcomes, depending on the complexity of the problems involved.</p> <h3 id="what-a-proof-could-look-like">What a Proof Could Look Like</h3> <p>There are different ways a proof about \(P=NP\) might look:</p> <ol> <li> <p><strong>\(P=NP\) with a Practical Algorithm:</strong> If someone finds a quick algorithm for SAT (a problem in \(NP\)), it would mean \(P=NP\) and many difficult problems would suddenly become easy to solve. This would change a lot of things, like making cryptography (codes) less secure.</p> </li> <li> <p><strong>\(P=NP\) with a Theoretical Algorithm:</strong> If someone finds an algorithm that solves SAT but it takes a very long time (like \(n^{10}\)), it would mean \(P=NP\), but it wouldn’t change much practically because the algorithm would be too slow to be useful.</p> </li> <li> <p><strong>\(P=NP\) with an Impractical Algorithm:</strong> If the algorithm takes a ridiculously long time (like \(n^{2222}\)), it would mean \(P=NP\), but it would be more of a theoretical result with no practical impact.</p> </li> <li> <p><strong>\(P≠NP\):</strong> If someone proves that no algorithm can solve SAT quickly, it would mean \(P≠NP\), and our current understanding of hard problems would remain.</p> </li> </ol> <h3 id="mathematical-explanation">Mathematical Explanation</h3> <p>Let’s break down some of the math involved:</p> <ul> <li> <p><strong>SAT Problem:</strong> This is a classic problem in \(NP\). It asks if there is a way to assign true or false values to variables in a logical formula so that the whole formula becomes true.</p> </li> <li> <p><strong>Polynomial Time:</strong> If a problem can be solved in polynomial time, it means there is an algorithm that can solve it in a time that can be expressed as a polynomial function of the size of the input. For example, if solving a problem takes \(n^2\) steps for an input of size \(n\), it’s considered polynomial time.</p> </li> <li> <p><strong>Exponential Time:</strong> If a problem takes an amount of time that grows exponentially with the input size, like \(2^n\), it’s considered very hard to solve because the time increases very quickly as \(n\) grows.</p> </li> </ul> <p><strong>Why \(P=NP\) is Complicated</strong></p> <p>Proving \(P=NP\) or \(P≠NP\) is not straightforward. Here are some reasons why:</p> <ol> <li> <p><strong>No Single Bad Example:</strong> Unlike RH, where one counterexample can disprove it, \(P=NP\) involves proving something about all possible algorithms and all possible problems in \(NP\).</p> </li> <li> <p><strong>Multiple Possibilities:</strong> There are many ways \(P\) could be related to \(NP\). It could be that some problems in \(NP\) are easier than others, or there could be an algorithm we haven’t discovered yet that solves all \(NP\) problems quickly.</p> </li> </ol> <h3 id="mathematical-equations-explained">Mathematical Equations Explained</h3> <ol> <li><strong>Polynomial Time Algorithms</strong></li> </ol> <p>A polynomial time algorithm is one where the time to solve the problem can be written as a polynomial expression of the input size \(n\). For example:</p> <p>[ T(n) = n^2 ]</p> <p>Here, \(T(n)\) represents the time it takes to solve the problem when the input size is \(n\). If \(n = 10\), then \(T(10) = 10^2 = 100\) steps.</p> <ol> <li><strong>Exponential Time Algorithms</strong></li> </ol> <p>An exponential time algorithm grows much faster than polynomial time. It can be written as:</p> <p>[ T(n) = 2^n ]</p> <p>For example, if \(n = 10\), then \(T(10) = 2^{10} = 1024\) steps. This is much larger than the 100 steps for a polynomial time algorithm with the same input size.</p> <ol> <li><strong>The SAT Problem</strong></li> </ol> <p>The SAT (satisfiability) problem asks if there is a way to assign true or false values to variables in a logical formula so that the whole formula becomes true. For example, given the formula:</p> <p>[ (A \lor B) \land (\neg A \lor C) \land (\neg B \lor \neg C) ]</p> <p>The question is whether there is a combination of truth values (true/false) for \(A\), \(B\), and \(C\) that makes the entire formula true.</p> <ol> <li><strong>Cook-Levin Theorem</strong></li> </ol> <p>This theorem shows that SAT is \(NP\)-complete, meaning it is one</p> <p>of the hardest problems in \(NP\). If we can solve SAT quickly (in polynomial time), we can solve all \(NP\) problems quickly.</p> <h3 id="conclusion">Conclusion</h3> <p>Understanding these concepts and equations helps in grasping the complexity of the \(P=NP\) question. The problem is about finding efficient algorithms for difficult problems and has significant implications for various fields like cryptography, optimisation, and beyond.</p> <h2 id="example-of-a-problem-in-p">Example of a Problem in P</h2> <ul> <li> <p><strong>Sorting a List</strong></p> <p>One example of a problem in P is sorting a list of numbers. There are many algorithms to do this, such as quicksort, mergesort, or heapsort. These algorithms can sort a list of \(n\) numbers in polynomial time, specifically \(O(n \log n)\) time.</p> <ul> <li><strong>Problem:</strong> Sort the list [3, 1, 4, 1, 5, 9].</li> <li><strong>Solution:</strong> Use an algorithm like mergesort.</li> <li><strong>Time Complexity:</strong> \(O(n \log n)\).</li> </ul> <p>The sorting problem is in P because it can be solved quickly for any list of numbers.</p> </li> </ul> <h2 id="example-of-a-problem-in-np">Example of a Problem in NP</h2> <ul> <li> <p><strong>Sudoku Puzzle</strong></p> <p>A clearer example of a problem in NP is solving a Sudoku puzzle.</p> <ul> <li><strong>Problem:</strong> Fill a 9x9 grid so that each row, each column, and each of the nine 3x3 subgrids contain all of the digits from 1 to 9.</li> <li><strong>Solution:</strong> Finding the solution from scratch can be difficult and time-consuming, especially for more complex puzzles.</li> <li><strong>Verification:</strong> If someone gives you a completed Sudoku grid, you can quickly check whether it is correct by ensuring that each row, each column, and each 3x3 subgrid contains all of the digits from 1 to 9 without any repetitions. This verification process can be done in polynomial time.</li> </ul> </li> <li> <p><strong>The Travelling Salesman Problem (TSP)</strong></p> <p>An example of a problem in NP is the Travelling Salesman Problem (TSP). In this problem, a salesman has to visit a number of cities exactly once and return to the starting city. The goal is to find the shortest possible route that visits each city.</p> <ul> <li><strong>Problem:</strong> Given a list of cities and the distances between them, find the shortest route that visits each city once and returns to the starting city.</li> <li><strong>Solution:</strong> There is no known polynomial-time algorithm to find the shortest route, but if someone gives you a route, you can quickly check if it is the shortest by calculating the total distance.</li> <li><strong>Verification:</strong> Checking the total distance of a given route is easy and can be done in polynomial time.</li> </ul> <p>The TSP is in NP because, while finding the shortest route is hard, checking the length of a given route is easy.</p> </li> </ul> <h2 id="how-they-relate-to-pnp">How They Relate to P=NP</h2> <ul> <li><strong>P Problems:</strong> Problems that can be solved quickly by a computer. Example: Sorting a list.</li> <li><strong>NP Problems:</strong> Problems where solutions can be verified quickly by a computer, even if finding the solution might be hard. Examples: Solving a Sudoku puzzle, finding the shortest route in the Travelling Salesman Problem.</li> </ul> <h2 id="why-tsp-is-harder-to-verify">Why TSP is Harder to Verify</h2> <p>For TSP, verifying if a given route is the shortest isn’t straightforward because you would need to compare it to all possible routes to ensure there isn’t a shorter one. This comparison process is what makes it difficult and is why TSP is classified as an NP-complete problem. NP-complete problems are the hardest problems in NP, meaning that if you can solve any NP-complete problem quickly, you can solve all NP problems quickly.</p> <h2 id="summary">Summary</h2> <ul> <li><strong>P Problems:</strong> Easy to solve and easy to check. Example: Sorting a list.</li> <li><strong>NP Problems:</strong> Hard to solve but easy to check if you have a solution. Examples: Sudoku, Travelling Salesman Problem.</li> <li><strong>NP-Complete Problems:</strong> Hard to solve and hard to verify as the shortest or optimal solution. Example: Travelling Salesman Problem.</li> </ul> <p>By understanding these examples, you can better grasp the differences between problems that are easy for computers to solve and those that are hard but whose solutions can be quickly verified once found.</p>]]></content><author><name></name></author><category term="computer science"/><summary type="html"><![CDATA[Understanding P and NP]]></summary></entry><entry><title type="html">What is SAT?</title><link href="https://haydarjawad.github.io/blog/2022/distill1/" rel="alternate" type="text/html" title="What is SAT?"/><published>2022-05-24T00:00:00+00:00</published><updated>2022-05-24T00:00:00+00:00</updated><id>https://haydarjawad.github.io/blog/2022/distill1</id><content type="html" xml:base="https://haydarjawad.github.io/blog/2022/distill1/"><![CDATA[<h1 style="text-align: center; color:yellow !important;">What is SAT?</h1> <h5 id="haydar-jawad-may-2022">Haydar jawad, May 2022</h5> <p><strong>SAT (Satisfiability Problem):</strong></p> <ul> <li>SAT stands for “Satisfiability.” It’s a type of problem in computer science and logic.</li> </ul> <p><strong>Imagine a Puzzle:</strong></p> <ul> <li>Think of SAT as a puzzle made up of pieces called “clauses.” Each clause is like a little rule that involves some items. The goal of the SAT puzzle is to find a way to arrange these items so that all the rules are followed.</li> </ul> <p><strong>Example with True/False Statements:</strong></p> <ul> <li>Suppose you have some statements that can be either true or false. For instance: <ul> <li>A = “I will eat an apple.”</li> <li>B = “I will go for a walk.”</li> <li>C = “I will read a book.”</li> </ul> </li> <li>Now, imagine some rules (clauses) about these statements: <ul> <li>Rule 1: Either I will eat an apple (A) or I will go for a walk (B).</li> <li>Rule 2: If I go for a walk (B), then I will read a book (C).</li> <li>Rule 3: I cannot both eat an apple (A) and read a book (C).</li> </ul> </li> <li>The SAT problem asks: “Can you find a way to make these statements true or false so that all the rules are satisfied?”</li> </ul> <p><strong>More Formally:</strong></p> <ul> <li>In SAT, you have a bunch of variables (like A, B, and C) that can be true or false.</li> <li>You have clauses (rules) that specify conditions involving these variables.</li> <li>The task is to determine if there’s a way to assign true/false values to the variables so that all the clauses are satisfied (all rules are followed).</li> </ul> <p><strong>Why is SAT Important?</strong></p> <ul> <li>SAT is important because it’s a fundamental problem in computer science. Many other problems can be transformed into a SAT problem.</li> <li>If you can solve SAT quickly, you can solve many other problems quickly too.</li> </ul> <p><strong>Challenge in Proving P≠NP with SAT:</strong></p> <ul> <li>Proving that there’s no quick way to solve SAT (and thus no quick way to solve all problems in NP) is a huge challenge. This is what the P=NP question is all about.</li> </ul> <p>In simple terms, SAT is like a giant, complex logic puzzle. Solving it means finding a way to make all the rules work together, and proving whether there’s a fast solution to this kind of puzzle is a big, unanswered question in computer science.</p>]]></content><author><name></name></author><category term="computer science"/><summary type="html"><![CDATA[What is SAT?]]></summary></entry><entry><title type="html">The P versus NP problem</title><link href="https://haydarjawad.github.io/blog/2022/distill/" rel="alternate" type="text/html" title="The P versus NP problem"/><published>2022-05-23T00:00:00+00:00</published><updated>2022-05-23T00:00:00+00:00</updated><id>https://haydarjawad.github.io/blog/2022/distill</id><content type="html" xml:base="https://haydarjawad.github.io/blog/2022/distill/"><![CDATA[<h1 style="text-align: center; color:yellow !important;">P and NP problem: What is the Fuss All About?</h1> <h5 id="haydar-jawad-may-2022">Haydar jawad, May 2022</h5> <h4 id="what-is-an-algorithm">What is an Algorithm?</h4> <p>An algorithm is like a recipe or a set of instructions that tells a computer how to solve a problem. For example, if you want to bake a cake, the recipe gives you step-by-step directions. Similarly, an algorithm gives step-by-step directions to solve a problem or perform a task.</p> <h4 id="tiny-but-powerful">Tiny but Powerful:</h4> <p>Even small algorithms can solve very important and complicated problems. For example, the algorithm used for encrypting data (keeping information safe and private) is based on prime numbers and is very short but extremely powerful.</p> <h4 id="example-of-a-tiny-algorithm">Example of a Tiny Algorithm:</h4> <p>There’s a famous algorithm for testing whether a number is a prime (a number that has no divisors other than (1) and itself). This algorithm can be written in just a few lines but is very powerful because it helps secure online transactions.</p> <p>(P) vs (NP) Problem:</p> <p>On (P=NP) problem, one can asks whether every problem that can be checked quickly by a computer can also be solved quickly by a computer. This is one of the biggest unanswered questions in computer science.</p> <p>Imagine you have a really difficult puzzle. (P=NP) is like asking if there’s a super-fast way to solve the puzzle, not just check if a solution is correct.</p> <h4 id="challenge-in-proving-pnp">Challenge in Proving (P≠NP):</h4> <p>Proving that there is no quick solution for certain problems (like SAT, which involves solving logical puzzles) is very hard. Even proving that there isn’t a short algorithm for these problems is a big challenge.</p> <h3 id="why-it-matters">Why It Matters:</h3> <p>Understanding whether (P=NP) is important because if someone finds a fast algorithm to solve these hard problems, it could change the world. For example, it could break the encryption that keeps our online data safe, or it could help solve many other complex problems quickly.</p> <h4 id="conclusion">Conclusion:</h4> <p>Algorithms may be small, but they are essential for solving big problems in our world. The quest to understand the (P=NP) problem is crucial for the future of computing and technology.</p>]]></content><author><name></name></author><category term="computer science"/><summary type="html"><![CDATA[P and NP problem: What is the Fuss All About?]]></summary></entry></feed>