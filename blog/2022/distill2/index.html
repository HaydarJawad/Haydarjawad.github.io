<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Understanding P and NP | Haydar A Jawad </title> <meta name="author" content="Haydar A Jawad"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon-32x32.png?e7771095cc0925502a6fca934729abfd"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://haydarjawad.github.io/blog/2022/distill2/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Understanding P and NP",
            "description": "",
            "published": "May 25, 2022",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Haydar</span> A Jawad </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Understanding P and NP</h1> <p></p> </d-title> <d-article> <h1 style="text-align: center; color: blue !important;">Understanding P and NP </h1> <h5 id="haydar-jawad-may-2022">Haydar jawad, May 2022</h5> <p><strong>Understanding \(P\) and \(NP\)</strong></p> <p>Imagine you have a bunch of puzzles. Some puzzles are easy to solve, while others are easy to check if someone else has solved them correctly. In computer science, the puzzles that are easy to solve are in a group called \(P\) (Polynomial time). The puzzles that are easy to check are in a group called \(NP\) (Nondeterministic Polynomial time). The big question is whether every puzzle that is easy to check (\(NP\)) is also easy to solve (\(P\)). This question is known as “Is \(P=NP\)?”.</p> <p><strong>Riemann Hypothesis vs. \(P=NP\)</strong></p> <p>The Riemann Hypothesis (RH) is another famous problem in mathematics. It deals with prime numbers and how they are spread out. If someone finds one exception to RH, it would mean RH is false. But \(P=NP\) is more complex. If \(P\) were equal to \(NP\), it could mean different things about how difficult or easy it is to solve certain problems.</p> <h3 id="the-riemann-hypothesis-explained">The Riemann Hypothesis Explained</h3> <p>The Riemann Hypothesis is about prime numbers and a special function called the Riemann zeta function, written as \(\zeta(s)\). This function is defined for complex numbers and is given by:</p> <p>[ \zeta(s) = \sum_{n=1}^{\infty} \frac{1}{n^s} ]</p> <p>Let’s break this down:</p> <ul> <li>\(\zeta(s)\): This is the Riemann zeta function.</li> <li>\(\sum_{n=1}^{\infty}\): This means you are adding up an infinite series of numbers.</li> <li>\(\frac{1}{n^s}\): This means you take each number \(n\), raise it to the power of \(s\), and then take the reciprocal (1 divided by that number).</li> </ul> <p>The Riemann Hypothesis says that all the interesting solutions to the equation \(\zeta(s) = 0\) lie on a specific line in the complex number plane. This line is called the “critical line,” and it is where the real part of \(s\) is \(\frac{1}{2}\). So, if \(s = \frac{1}{2} + bi\) (where \(b\) is a real number), the Riemann Hypothesis predicts that all the non-trivial zeros of the zeta function lie on this line.</p> <h3 id="comparison-with-pnp">Comparison with \(P=NP\)</h3> <p>The Riemann Hypothesis is a “yes or no” question: either all the non-trivial zeros lie on the critical line, or they don’t. If one zero is found off the line, the hypothesis is false. This is different from the \(P=NP\) problem, which has multiple potential outcomes, depending on the complexity of the problems involved.</p> <h3 id="what-a-proof-could-look-like">What a Proof Could Look Like</h3> <p>There are different ways a proof about \(P=NP\) might look:</p> <ol> <li> <p><strong>\(P=NP\) with a Practical Algorithm:</strong> If someone finds a quick algorithm for SAT (a problem in \(NP\)), it would mean \(P=NP\) and many difficult problems would suddenly become easy to solve. This would change a lot of things, like making cryptography (codes) less secure.</p> </li> <li> <p><strong>\(P=NP\) with a Theoretical Algorithm:</strong> If someone finds an algorithm that solves SAT but it takes a very long time (like \(n^{10}\)), it would mean \(P=NP\), but it wouldn’t change much practically because the algorithm would be too slow to be useful.</p> </li> <li> <p><strong>\(P=NP\) with an Impractical Algorithm:</strong> If the algorithm takes a ridiculously long time (like \(n^{2222}\)), it would mean \(P=NP\), but it would be more of a theoretical result with no practical impact.</p> </li> <li> <p><strong>\(P≠NP\):</strong> If someone proves that no algorithm can solve SAT quickly, it would mean \(P≠NP\), and our current understanding of hard problems would remain.</p> </li> </ol> <h3 id="mathematical-explanation">Mathematical Explanation</h3> <p>Let’s break down some of the math involved:</p> <ul> <li> <p><strong>SAT Problem:</strong> This is a classic problem in \(NP\). It asks if there is a way to assign true or false values to variables in a logical formula so that the whole formula becomes true.</p> </li> <li> <p><strong>Polynomial Time:</strong> If a problem can be solved in polynomial time, it means there is an algorithm that can solve it in a time that can be expressed as a polynomial function of the size of the input. For example, if solving a problem takes \(n^2\) steps for an input of size \(n\), it’s considered polynomial time.</p> </li> <li> <p><strong>Exponential Time:</strong> If a problem takes an amount of time that grows exponentially with the input size, like \(2^n\), it’s considered very hard to solve because the time increases very quickly as \(n\) grows.</p> </li> </ul> <p><strong>Why \(P=NP\) is Complicated</strong></p> <p>Proving \(P=NP\) or \(P≠NP\) is not straightforward. Here are some reasons why:</p> <ol> <li> <p><strong>No Single Bad Example:</strong> Unlike RH, where one counterexample can disprove it, \(P=NP\) involves proving something about all possible algorithms and all possible problems in \(NP\).</p> </li> <li> <p><strong>Multiple Possibilities:</strong> There are many ways \(P\) could be related to \(NP\). It could be that some problems in \(NP\) are easier than others, or there could be an algorithm we haven’t discovered yet that solves all \(NP\) problems quickly.</p> </li> </ol> <h3 id="mathematical-equations-explained">Mathematical Equations Explained</h3> <ol> <li><strong>Polynomial Time Algorithms</strong></li> </ol> <p>A polynomial time algorithm is one where the time to solve the problem can be written as a polynomial expression of the input size \(n\). For example:</p> <p>[ T(n) = n^2 ]</p> <p>Here, \(T(n)\) represents the time it takes to solve the problem when the input size is \(n\). If \(n = 10\), then \(T(10) = 10^2 = 100\) steps.</p> <ol> <li><strong>Exponential Time Algorithms</strong></li> </ol> <p>An exponential time algorithm grows much faster than polynomial time. It can be written as:</p> <p>[ T(n) = 2^n ]</p> <p>For example, if \(n = 10\), then \(T(10) = 2^{10} = 1024\) steps. This is much larger than the 100 steps for a polynomial time algorithm with the same input size.</p> <ol> <li><strong>The SAT Problem</strong></li> </ol> <p>The SAT (satisfiability) problem asks if there is a way to assign true or false values to variables in a logical formula so that the whole formula becomes true. For example, given the formula:</p> <p>[ (A \lor B) \land (\neg A \lor C) \land (\neg B \lor \neg C) ]</p> <p>The question is whether there is a combination of truth values (true/false) for \(A\), \(B\), and \(C\) that makes the entire formula true.</p> <ol> <li><strong>Cook-Levin Theorem</strong></li> </ol> <p>This theorem shows that SAT is \(NP\)-complete, meaning it is one</p> <p>of the hardest problems in \(NP\). If we can solve SAT quickly (in polynomial time), we can solve all \(NP\) problems quickly.</p> <h3 id="conclusion">Conclusion</h3> <p>Understanding these concepts and equations helps in grasping the complexity of the \(P=NP\) question. The problem is about finding efficient algorithms for difficult problems and has significant implications for various fields like cryptography, optimisation, and beyond.</p> <h2 id="example-of-a-problem-in-p">Example of a Problem in P</h2> <ul> <li> <p><strong>Sorting a List</strong></p> <p>One example of a problem in P is sorting a list of numbers. There are many algorithms to do this, such as quicksort, mergesort, or heapsort. These algorithms can sort a list of \(n\) numbers in polynomial time, specifically \(O(n \log n)\) time.</p> <ul> <li> <strong>Problem:</strong> Sort the list [3, 1, 4, 1, 5, 9].</li> <li> <strong>Solution:</strong> Use an algorithm like mergesort.</li> <li> <strong>Time Complexity:</strong> \(O(n \log n)\).</li> </ul> <p>The sorting problem is in P because it can be solved quickly for any list of numbers.</p> </li> </ul> <h2 id="example-of-a-problem-in-np">Example of a Problem in NP</h2> <ul> <li> <p><strong>Sudoku Puzzle</strong></p> <p>A clearer example of a problem in NP is solving a Sudoku puzzle.</p> <ul> <li> <strong>Problem:</strong> Fill a 9x9 grid so that each row, each column, and each of the nine 3x3 subgrids contain all of the digits from 1 to 9.</li> <li> <strong>Solution:</strong> Finding the solution from scratch can be difficult and time-consuming, especially for more complex puzzles.</li> <li> <strong>Verification:</strong> If someone gives you a completed Sudoku grid, you can quickly check whether it is correct by ensuring that each row, each column, and each 3x3 subgrid contains all of the digits from 1 to 9 without any repetitions. This verification process can be done in polynomial time.</li> </ul> </li> <li> <p><strong>The Travelling Salesman Problem (TSP)</strong></p> <p>An example of a problem in NP is the Travelling Salesman Problem (TSP). In this problem, a salesman has to visit a number of cities exactly once and return to the starting city. The goal is to find the shortest possible route that visits each city.</p> <ul> <li> <strong>Problem:</strong> Given a list of cities and the distances between them, find the shortest route that visits each city once and returns to the starting city.</li> <li> <strong>Solution:</strong> There is no known polynomial-time algorithm to find the shortest route, but if someone gives you a route, you can quickly check if it is the shortest by calculating the total distance.</li> <li> <strong>Verification:</strong> Checking the total distance of a given route is easy and can be done in polynomial time.</li> </ul> <p>The TSP is in NP because, while finding the shortest route is hard, checking the length of a given route is easy.</p> </li> </ul> <h2 id="how-they-relate-to-pnp">How They Relate to P=NP</h2> <ul> <li> <strong>P Problems:</strong> Problems that can be solved quickly by a computer. Example: Sorting a list.</li> <li> <strong>NP Problems:</strong> Problems where solutions can be verified quickly by a computer, even if finding the solution might be hard. Examples: Solving a Sudoku puzzle, finding the shortest route in the Travelling Salesman Problem.</li> </ul> <h2 id="why-tsp-is-harder-to-verify">Why TSP is Harder to Verify</h2> <p>For TSP, verifying if a given route is the shortest isn’t straightforward because you would need to compare it to all possible routes to ensure there isn’t a shorter one. This comparison process is what makes it difficult and is why TSP is classified as an NP-complete problem. NP-complete problems are the hardest problems in NP, meaning that if you can solve any NP-complete problem quickly, you can solve all NP problems quickly.</p> <h2 id="summary">Summary</h2> <ul> <li> <strong>P Problems:</strong> Easy to solve and easy to check. Example: Sorting a list.</li> <li> <strong>NP Problems:</strong> Hard to solve but easy to check if you have a solution. Examples: Sudoku, Travelling Salesman Problem.</li> <li> <strong>NP-Complete Problems:</strong> Hard to solve and hard to verify as the shortest or optimal solution. Example: Travelling Salesman Problem.</li> </ul> <p>By understanding these examples, you can better grasp the differences between problems that are easy for computers to solve and those that are hard but whose solutions can be quickly verified once found.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Haydar A Jawad. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>